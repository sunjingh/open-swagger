import { CoreConfig } from "../utils";
import { jsTemplate, tsTemplate } from "./template";
import { OpenAPIV2 } from "openapi-types";
import { sortBy, uniq, flattenDeep, mapKeys, upperFirst, set } from "lodash";
// @ts-ignore
import Converter from "api-spec-converter";

export const createTagsByPaths = (
  paths: OpenAPIV2.PathsObject
): OpenAPIV2.TagObject[] =>
  // @ts-ignore
  sortBy(
    uniq(
      flattenDeep(
        Object.values(paths).map((item: OpenAPIV2.PathItemObject) =>
          Object.values(item).map(
            (item: OpenAPIV2.OperationObject) => item?.tags ?? ""
          )
        )
      ).filter(Boolean)
    )
  ).map((item) => ({ name: item }));

// 部分 swagger 文档会存在 a.b 的 model 定义
// abc.def.ghi -> AbcDefGhi
export const normalizeDefinitionName = (name: string) =>
  upperFirst(name.replace(/\.(\w)/g, (_, $1) => $1.toUpperCase()));

export const normalizeDefinitions = (
  definitions: OpenAPIV2.DefinitionsObject
) => mapKeys(definitions, (value, key) => normalizeDefinitionName(key));

// 补充缺失的 source 属性
export const normalizeSource = (source: OpenAPIV2.Document) => ({
  ...source,
  tags: source.tags ?? createTagsByPaths(source.paths),
  definitions: normalizeDefinitions(source.definitions!),
});

// openapi3 -> openapi2
export const transformSource = async (source: OpenAPIV2.Document) => {
  // @ts-ignore
  if (source.openapi) {
    const convertedSource = (
      await Converter.convert({
        from: "openapi_3",
        to: "swagger_2",
        source,
      })
    ).spec;

    const handleFormdataRequestParams = (obj: any, name: string) => {
      const resultObj = {};
      const needTanslateObjNames = new Set<string>();
      Object.entries(obj).forEach(([k, v]: [string, any]) => {
        if (v?.name?.includes(".")) {
          const endObjName = v.name.split(".").at(0);
          needTanslateObjNames.add(endObjName);
          v.name = v.name.split(".").at(-1);
          set(resultObj, v.name, v);
          set(obj, endObjName, { $ref: `#/definitions/${endObjName}_In` });
          delete obj[k];
        }
      });

      needTanslateObjNames.forEach((ele) => {
        handleFormdataRequestParams(resultObj, `${ele}_In`);
      });

      convertedSource.definitions[name] = {
        type: "object",
        properties: obj,
        additionalProperties: false,
      };
    };

    for (const key in convertedSource.paths) {
      if (
        convertedSource.paths[key]?.post?.consumes?.includes(
          "multipart/form-data"
        )
      ) {
        const obj = convertedSource.paths[key].post.parameters?.reduce(
          (target: any, current: any) => {
            // 处理文件类型
            if (current?.items?.format === "binary") {
              current.items.type = "";
            }
            target[current.name] = current;
            // 处理枚举类型
            if (
              current?.enum?.length &&
              Object.keys(convertedSource.definitions).includes(
                `Enum${current.name}`
              )
            ) {
              target[current.name] = {
                $ref: `#/definitions/Enum${current.name}`,
              };
            }

            // console.log('current===>', current);

            // 处理Date类型
            if (current?.format === "date-time") {
              current.type = "Date";
            }
            return target;
          },
          {}
        );
        let typeName = `${key.split("/").at(-1)}_In`;
        // 如果名字存在则追加_Formdata
        if (Object.keys(convertedSource.definitions).includes(typeName)) {
          typeName = `${typeName}_Formdata`;
        }
        handleFormdataRequestParams(obj, typeName);
        convertedSource.paths[key].post.parameters = [
          {
            description: "",
            name: "body",
            in: "formData",
            schema: { $ref: "#/definitions/" + typeName },
          },
        ];
      }
    }

    return convertedSource;
  } else {
    return source;
  }
};

// 合并默认参数
export const mergeDefaultParams = async (
  config: CoreConfig
): Promise<Required<CoreConfig>> => {
  const normalizedSource = normalizeSource(
    await transformSource(config.source)
  );
  return {
    jsDoc: true,
    interface: false,
    typedef: false,
    recursive: false,
    lang: "js",
    templateFunction:
      config.lang === "ts" ? eval(tsTemplate) : eval(jsTemplate),
    ...config,
    source: normalizedSource,
  };
};

export const createDefaultHeadCode = ({
  url,
  description,
  title,
  version,
  fileDescription,
}: {
  url?: string;
  description?: string;
  title?: string;
  version?: string;
  fileDescription?: string;
}) => {
  return `/* eslint-disable */
// @ts-nocheck

/**
 * generated by free-swagger-core
 * @see https://www.npmjs.com/package/free-swagger
${title ? ` * @title ${title}\n` : ""}${
    description ? ` * @description ${description}\n` : ""
  }${fileDescription ? ` * @fileDescription ${fileDescription}\n` : ""}${
    url ? ` * @host ${String(url)}\n` : ""
  }${version ? ` * @version ${version}\n` : ""}}
**/`;
};
